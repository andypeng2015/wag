// Copyright (c) 2016 Timo Savola. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86

import (
	"github.com/tsavola/wag/internal/gen"
	"github.com/tsavola/wag/internal/links"
	"github.com/tsavola/wag/internal/opers"
	"github.com/tsavola/wag/internal/regs"
	"github.com/tsavola/wag/internal/values"
	"github.com/tsavola/wag/wasm"
)

func (ISA) ConversionOp(code gen.RegCoder, oper uint16, resultType wasm.Type, source values.Operand) (result values.Operand) {
	switch oper {
	case opers.Wrap:
		return opWrap(code, resultType, source)

	default:
		return commonConversionOp(code, oper, resultType, source)
	}
}

func opWrap(code gen.RegCoder, resultType wasm.Type, source values.Operand) values.Operand {
	source.Type = wasm.I32 // short mov; useful zeroExt flag
	reg, zeroExt := opMaybeResultReg(code, source, false)
	return values.TempRegOperand(resultType, reg, zeroExt)
}

func commonConversionOp(code gen.RegCoder, oper uint16, resultType wasm.Type, source values.Operand) values.Operand {
	reg, zeroExt := opMaybeResultReg(code, source, false)
	// TODO: for int<->float ops: borrow source reg, allocate target reg

	switch oper {
	case opers.ExtendS:
		movsxd.opFromReg(code, 0, reg, reg)
		return values.TempRegOperand(resultType, reg, false)

	case opers.ExtendU:
		if !zeroExt {
			mov.opFromReg(code, wasm.I32, reg, reg)
		}
		return values.TempRegOperand(resultType, reg, false)

	case opers.Mote:
		cvts2sSSE.opFromReg(code, source.Type, reg, reg)
		return values.TempRegOperand(resultType, reg, false)

	case opers.TruncS:
		cvttsSSE2si.opReg(code, source.Type, resultType, RegResult, reg)
		code.FreeReg(source.Type, reg)
		return values.TempRegOperand(resultType, RegResult, true)

	case opers.TruncU:
		if resultType == wasm.I32 {
			cvttsSSE2si.opReg(code, source.Type, wasm.I64, RegResult, reg)
		} else {
			opTruncFloatToUnsignedI64(code, source.Type, reg)
		}
		code.FreeReg(source.Type, reg)
		return values.TempRegOperand(resultType, RegResult, false)

	case opers.ConvertS:
		cvtsi2sSSE.opReg(code, resultType, source.Type, RegResult, reg)
		code.FreeReg(source.Type, reg)
		return values.TempRegOperand(resultType, RegResult, false)

	case opers.ConvertU:
		if source.Type == wasm.I32 {
			if !zeroExt {
				mov.opFromReg(code, wasm.I32, reg, reg)
			}
			cvtsi2sSSE.opReg(code, resultType, wasm.I64, RegResult, reg)
		} else {
			opConvertUnsignedI64ToFloat(code, resultType, reg)
		}
		code.FreeReg(source.Type, reg)
		return values.TempRegOperand(resultType, RegResult, false)

	case opers.Reinterpret:
		if source.Type.Category() == wasm.Int {
			movSSE.opFromReg(code, source.Type, RegResult, reg)
		} else {
			movSSE.opToReg(code, source.Type, RegResult, reg)
		}
		code.FreeReg(source.Type, reg)
		return values.TempRegOperand(resultType, RegResult, true)
	}

	panic("unknown conversion op")
}

func opTruncFloatToUnsignedI64(code gen.Coder, sourceType wasm.Type, inputReg regs.R) {
	// this algorithm is copied from code generated by gcc and clang:

	roDataAddr := code.RODataAddr()
	truncMaskAddr := gen.MaskAddr(roDataAddr, gen.MaskTruncBase, sourceType)

	movapSSE.opFromReg(code, sourceType, RegScratch, inputReg)
	subsSSE.opFromAddr(code, sourceType, RegScratch, 0, NoIndex, truncMaskAddr)
	cvttsSSE2si.opReg(code, sourceType, wasm.I64, RegResult, RegScratch)
	mov.opFromAddr(code, wasm.I64, RegScratch, 0, NoIndex, roDataAddr+gen.ROMask80Addr64)
	xor.opFromReg(code, wasm.I64, RegScratch, RegResult)
	cvttsSSE2si.opReg(code, sourceType, wasm.I64, RegResult, inputReg)
	ucomisSSE.opFromAddr(code, sourceType, inputReg, 0, NoIndex, truncMaskAddr)
	cmovae.opFromReg(code, wasm.I64, RegResult, RegScratch)
}

func opConvertUnsignedI64ToFloat(code gen.Coder, resultType wasm.Type, inputReg regs.R) {
	// this algorithm is copied from code generated by gcc and clang:

	var done links.L
	var huge links.L

	// TODO: allocate target reg

	test.opFromReg(code, wasm.I64, inputReg, inputReg)
	js.rel8.opStub(code)
	huge.AddSite(code.Pos())

	// max. 63-bit value
	cvtsi2sSSE.opReg(code, resultType, wasm.I64, RegResult, inputReg)

	jmpRel.rel8.opStub(code)
	done.AddSite(code.Pos())

	huge.Addr = code.Pos()
	updateLocalBranches(code, &huge)

	// 64-bit value
	mov.opFromReg(code, wasm.I64, RegScratch, inputReg)
	and.opImm(code, wasm.I64, RegScratch, 1)
	shrImm.op(code, wasm.I64, inputReg, 1)
	or.opFromReg(code, wasm.I64, inputReg, RegScratch)
	cvtsi2sSSE.opReg(code, resultType, wasm.I64, RegResult, inputReg)
	addsSSE.opFromReg(code, resultType, RegResult, RegResult)

	done.Addr = code.Pos()
	updateLocalBranches(code, &done)
}
